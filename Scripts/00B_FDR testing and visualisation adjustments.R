
#This script allows the correct annotation of variants to create the figures in the manuscript and performs FDR testing of the variants

## Import required packages
require(readxl)
require(dplyr)
require(stringr)
require(Biostrings)

## Load input files generated with the script 00A_Filtering and centering.R

load("Designed_variants.RData")
INDEL.df <- as.data.frame(read.table("IAPP_indels_centered_data.tsv", sep='\t', header=TRUE))
Synonymous.df <- as.data.frame(read.table("IAPP_synonymous.tsv", sep='\t', header=TRUE))

AllVariantsDesigned.df$aa_seq <- as.character(AllVariantsDesigned.df$aa_seq)
INDEL.df <- inner_join(INDEL.df, AllVariantsDesigned.df, by = "aa_seq")
INDEL.df <- INDEL.df[!(duplicated(INDEL.df$aa_seq)), ]
INDEL.df[grepl(x = INDEL.df$name, pattern = "kmer"), ]$mut_type <- "Truncation"

#I want to filter out the variants with high sigmas. I normalise sigma values by dividing them by the nucleation score range of the library.
#I will discard all variants with a normalised sigma greater than 1/4 of the nucleation score range.
INDEL.df$sigma_norm <- ""
fitness_range = abs(quantile(INDEL.df$nscore_c, probs = 0.25) - quantile(INDEL.df$nscore_c, probs = 0.75))
for (i in 1:nrow(INDEL.df)){INDEL.df[i,]$sigma_norm <- INDEL.df[i,]$sigma/fitness_range}
INDEL.df$sigma_norm <- as.numeric(INDEL.df$sigma_norm)
INDEL.df <- INDEL.df[INDEL.df$sigma_norm < fitness_range/4,  ]

# Variant significance testing: FDR 

INDEL.df$zscore<-INDEL.df$nscore_c/INDEL.df$sigma
INDEL.df$p.adjust<-p.adjust(2*pnorm(-abs(INDEL.df$zscore)), method = "BH")
INDEL.df <- INDEL.df %>% mutate(sig_fdr = p.adjust < 0.1)

#I need to set up sig_10 = TRUE for non-nucleating variants
INDEL.df[is.na(INDEL.df$sigma), ]$sig_fdr <- TRUE
INDEL.df$category_fdr <- "WT-like"
INDEL.df$category_fdr[INDEL.df$sig_fdr == TRUE & INDEL.df$nscore_c < 0] <- "NS-"
INDEL.df$category_fdr[INDEL.df$sig_fdr == TRUE & INDEL.df$nscore_c > 0] <- "NS+"

#Divide dataset into mutation types: single AA substitutions, single AA insertions, single AA deletions, truncations, variants generated by polymerase slippage and internal deletions
Singles.df <- INDEL.df[INDEL.df$mut_type == "Singles" & is.na(INDEL.df$mut_type) == FALSE,]
SingleInsertions.df <- INDEL.df[INDEL.df$mut_type == "Single insertion" & is.na(INDEL.df$mut_type) == FALSE,]
Deletions.df <- INDEL.df[INDEL.df$mut_type == "Deletion" & is.na(INDEL.df$mut_type) == FALSE,]
Stops.df <- INDEL.df[INDEL.df$mut_type == "STOP" & is.na(INDEL.df$mut_type) == FALSE,]
SingleDeletions.df <- INDEL.df[INDEL.df$mut_type == "Single deletion" & is.na(INDEL.df$mut_type) == FALSE,]
PolSlip.df <- INDEL.df[INDEL.df$mut_type == "PolSlip" & is.na(INDEL.df$mut_type) == FALSE,]
Truncations.df <- INDEL.df[INDEL.df$mut_type == "Truncation" & is.na(INDEL.df$mut_type) == FALSE, ]

# Annotate each dataset with position, mutation from and mutation to, and create duplicate rows for variants that have the same sequences for visualization purposes. 

###########
# Singles #
###########

Singles.df$WT_AA <- ""
Singles.df$Pos <- ""
Singles.df$Mut <- ""

for(i in 1:nrow(Singles.df)){
  Singles.df[i,]$WT_AA <- as.character(seqinr::translate(seqinr::s2c(unlist(strsplit(Singles.df[i, ]$name, "_"))[4])))
  Singles.df[i,]$Pos <- unlist(strsplit(Singles.df[i,]$name, "_"))[1]
  Singles.df[i,]$Mut <- as.character(seqinr::translate(seqinr::s2c(unlist(strsplit(Singles.df[i, ]$name, "_"))[5])))
}

Singles.df$Pos <- as.numeric(Singles.df$Pos)


##########
# Stop   #
##########

Stops.df$WT_AA <- ""
Stops.df$Pos <- ""
Stops.df$Mut <- ""


for(i in 1:nrow(Stops.df)){
  Stops.df[i,]$WT_AA <- 
    Stops.df[i,]$Pos <- unlist(strsplit(Stops.df[i,]$name, "_"))[2]
  Stops.df[i,]$Mut <- "*"
}

Stops.df$Pos <- as.numeric(Stops.df$Pos)


##############
# Insertions #
##############

# The same coding sequence can be a result of different insertions, I will duplicate the rows for those cases. Example: KCNTAATCATQRLANFLVHSSNNFGAILSSTNVGSNTY can be obtained by inserting an A after position 4 or position 5. 

Insertions_reps <- Insertions.df
Insertions_reps$ins_pos <- ""
Insertions_reps$ins_aa <- ""

for (i in 1:nrow(Insertions_reps)){
  if(is.na(str_extract(Insertions_reps[i,]$name, ";"))){
    name <- unlist(str_split(Insertions_reps[i,]$name, "_"))
    Insertions_reps[i,]$ins_pos <- name[3]
    Insertions_reps[i,]$ins_aa <- name[4]
    
  } else {
    all_ID <- unlist(str_split(Insertions_reps[i,]$name, ";"))
    num_ID <- length(all_ID)
    
    for(j in all_ID){
      
      new_row <- Insertions_reps[i,]
      new_row$name <- j
      
      name <-unlist(str_split(j, "_"))
      
      new_row$ins_pos <- name[3]
      new_row$ins_aa <- name[4]
      
      Insertions_reps <- rbind(Insertions_reps, new_row)
      
    }
  }
}

#remove rows with more than one ID (they are already split)
Insertions_reps <- Insertions_reps[is.na(str_extract(Insertions_reps$name, ";")),]


SingleInsertions.df$ins_pos <- ""
SingleInsertions.df$ins_aa <- ""

for (i in 1:nrow(SingleInsertions.df)){
  
  if(is.na(str_extract(SingleInsertions.df[i,]$name, ";"))){
    
    name <- unlist(str_split(SingleInsertions.df[i,]$name, "_"))
    
    SingleInsertions.df[i,]$ins_pos <- name[3]
    SingleInsertions.df[i,]$ins_aa <- name[4]
    
  } else {
    
    all_ID <- unlist(str_split(SingleInsertions.df[i,]$name, ";"))
    num_ID <- length(all_ID)
    
    for(j in all_ID){
      
      new_row <- SingleInsertions.df[i,]
      new_row$name <- j
      
      name <-unlist(str_split(j, "_"))
      
      new_row$ins_pos <- name[3]
      new_row$ins_aa <- name[4]
      
      SingleInsertions.df <- rbind(SingleInsertions.df, new_row)
      
    }
  }
}

SingleInsertions.df <- SingleInsertions.df[is.na(str_extract(SingleInsertions.df$name, ";")),]


#######################
# Single AA deletions #
#######################

# The same coding sequence can be a result of different insertions, I will duplicate the rows for those cases. Example: KCNTATCATQRLANFLVHSSNNFGAILSTNVGSNTY can be obtained by deleting an S28 or S29. 

Single_deletions_reps <- SingleDeletions.df

Single_deletions_reps$del_pos <- ""
Single_deletions_reps$ID <- ""

for (i in 1:nrow(Single_deletions_reps)){
  
  if(is.na(str_extract(Single_deletions_reps[i,]$name, ";"))){
    ID <- unlist(str_split(Single_deletions_reps[i,]$name, "_"))
    Single_deletions_reps[i,]$del_pos<-unlist(strsplit(ID[3],"-"))[1]
    
  } else {
    
    all_ID <- unlist(str_split(Single_deletions_reps[i,]$name, ";"))
    
    for(j in all_ID){
      
      new_row <- Single_deletions_reps[i,]
      new_row$ID <- j
      ID <- unlist(str_split(j, "_"))
      
      new_row$del_pos <- unlist(strsplit(ID[3], "-"))[1]
      
      Single_deletions_reps <- rbind(Single_deletions_reps, new_row)
      
    }
  }
}

#remove rows with more than one ID (they are already split)
Single_deletions_reps <- Single_deletions_reps[is.na(str_extract(Single_deletions_reps$name, ";")),]
#also those that were kmers (=truncations)
Single_deletions_reps <- Single_deletions_reps[is.na(str_extract(Single_deletions_reps$name, "kmer")),]


######################
# Internal deletions #
######################

# The same coding sequence can be a result of different insertions, I will duplicate the rows for those cases. Example: KCNTATCATQRLANFLVHSSTNVGSNTY can be obtained by the following deletions: Δ19-27,  Δ20-28, and Δ21-29

Deletions_reps <- Deletions.df
Deletions_reps$ID <- ""
for(i in 1:nrow(Deletions_reps)){
  
  ID <- Deletions_reps[i, ]$name
  
  if(!is.na(str_extract(ID, ";"))){
    
    all_ID <- unlist(str_split(ID, ";"))
    
    #remove IDs that are kmers
    all_ID <- all_ID[is.na(str_extract(all_ID, "kmer"))]
    
    for(j in all_ID){
      
      new_row <- Deletions_reps[i,]
      new_row$ID <- j
      
      Deletions_reps <- rbind(Deletions_reps, new_row)
      
    }
  }
}

#remove rows with more than one ID (they are already split)
Deletions_reps<-Deletions_reps[is.na(str_extract(Deletions_reps$ID, ";")),]


# add info on start, end and length of deletion
Deletions_reps$del_length<-0
Deletions_reps$del_start<-0
Deletions_reps$del_end<-0

for(i in 1:nrow(Deletions_reps)){
  
  ID<-Deletions_reps[i,]$name
  
  positions<-unlist(strsplit(ID, "_"))[3]
  
  start<-as.numeric(unlist(strsplit(positions, "-"))[1])
  end<-as.numeric(unlist(strsplit(positions, "-"))[2])
  length<-end-start+1
  
  Deletions_reps[i,]$del_start<-start
  Deletions_reps[i,]$del_end<-end
  Deletions_reps[i,]$del_length<-length
}

# The same coding sequence can be a result of different insertions, I will duplicate the rows for those cases.

polslip_reps<-PolSlip.df
polslip_reps$ID <- ""


for(i in 1:nrow(polslip_reps)){
  
  ID<-polslip_reps[i,]$ID
  
  if(!is.na(str_extract(ID, ";"))){
    
    all_ID<-unlist(str_split(ID, ";"))
    
    #remove IDs that are kmers
    all_ID<-all_ID[is.na(str_extract(all_ID, "kmer"))]
    
    for(j in all_ID){
      
      new_row<- polslip_reps[i,]
      new_row$ID<-j
      
      polslip_reps<-rbind(polslip_reps,new_row)
      
    }}}

#remove rows with more than one ID (they are already split)
polslip_reps<-polslip_reps[is.na(str_extract(polslip_reps$ID, ";")),]


# add info on start, end and length of deletion
polslip_reps$first_aa_inserted<-0
polslip_reps$second_aa_inserted<-0
polslip_reps$aa_inserted<-0

for(i in 1:nrow(polslip_reps)){
  
  ID<-polslip_reps[i,]$ID
  
  
  start<-as.numeric(unlist(strsplit(ID, "_"))[3])
  
  if(!is.na(str_extract(ID, "c"))){
    end<-as.numeric(unlist(strsplit(ID, "_"))[3])+1
  }else{
    end<-as.numeric(unlist(strsplit(ID, "_"))[3])
  }
  
  length<-end-start+1
  
  polslip_reps[i,]$first_aa_inserted<-start
  polslip_reps[i,]$second_aa_inserted<-end
  polslip_reps[i,]$aa_inserted<-length
  
}

###############
# truncations #
###############

# labelled as kmers in library design
# they don't have repetitions- they are unique. those labelled also as deletions are now only truncations; just remove the deletions name
Truncation_reps <- Truncations.df
Truncation_reps$k_length<-""
Truncation_reps$k_start<-""
Truncation_reps$k_end<-""
Truncation_reps$ID <- ""

for (i in 1:nrow(Truncation_reps)){
  all_ID<-unlist(str_split(Truncation_reps[i,]$name, ";"))
  
  #remove IDs that are dels
  all_ID<-all_ID[is.na(str_extract(all_ID, "Del"))]
  
  num_ID<-length(all_ID)
  
  for(j in all_ID){
    
    new_row<- Truncation_reps[i,]
    new_row$ID<-j
    
    ID<-unlist(str_split(j, "_"))
    
    new_row$k_length<-gsub("kmer", "", ID[1])
    
    start_end<-unlist(str_split(ID[2], "-"))
    new_row$k_start<-start_end[1]
    new_row$k_end<-start_end[2]
    
    
    Truncation_reps <- rbind(Truncation_reps, new_row)
    
  }
}


Truncation_reps$k_start<-as.numeric(Truncation_reps$k_start)
Truncation_reps$k_end<-as.numeric(Truncation_reps$k_end)

#remove rows with more than one ID (they are already split)
Truncation_reps<-Truncation_reps[!(is.na(Truncation_reps$k_end)),]


#also add from which side the truncation starts
Truncation_reps$side<-"both"
Truncation_reps[Truncation_reps$k_end==37 , ]$side<-"Nterminal"
Truncation_reps[Truncation_reps$k_start==1 , ]$side<-"Cterminal"


save(INDEL.df, file = "INDEL.df.RData")
save(Singles.df, Stops.df, Insertions_reps, SingleInsertions.df, SingleDeletions.df, Single_deletions_reps, 
     Deletions.df, Deletions_reps, polslip_reps, PolSlip.df, Truncations.df, Truncation_reps, Synonymous.df, file="INDEL_datasets.RData")


